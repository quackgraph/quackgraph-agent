import type { QuackGraph } from '@quackgraph/graph';
import type {
  AgentConfig,
  LabyrinthArtifact,
  CorrelationResult,
  TimeContext,
  DomainConfig,
  MastraAgent
} from './types';
import { trace, type Span } from '@opentelemetry/api';

// Core Dependencies
import { setGraphInstance } from './lib/graph-instance';
import { mastra } from './mastra';
import { Chronos } from './agent/chronos';
import { GraphTools } from './tools/graph-tools';
import { SchemaRegistry } from './governance/schema-registry';

/**
 * The QuackGraph Agent Facade.
 * 
 * A Native Mastra implementation.
 * This class acts as a thin client that orchestrates the `labyrinth-workflow` 
 * and injects the RuntimeContext (Time Travel & Governance).
 */
export class Labyrinth {
  public chronos: Chronos;
  public tools: GraphTools;
  public registry: SchemaRegistry;
  
  // Simulating persistence layer for traces (In production, use Redis/DB via Mastra Storage)
  private traceCache = new Map<string, LabyrinthArtifact>();
  private logger = mastra.getLogger();
  private tracer = trace.getTracer('quackgraph-agent');

  constructor(
    graph: QuackGraph,
    _agents: {
      scout: MastraAgent;
      judge: MastraAgent;
      router: MastraAgent;
    },
    private config: AgentConfig
  ) {
    // Bridge Pattern: Inject the graph instance into the global scope
    // so Mastra Tools can access it without passing it through every step.
    setGraphInstance(graph);

    // Utilities
    this.tools = new GraphTools(graph);
    this.chronos = new Chronos(graph, this.tools);
    this.registry = new SchemaRegistry();
  }

  /**
   * Registers a semantic domain (LOD 0 governance).
   * Direct proxy to the singleton registry used by tools.
   */
  registerDomain(config: DomainConfig) {
    this.registry.register(config);
  }

  /**
   * Main Entry Point: Finds a path through the Labyrinth.
   * 
   * @param start - Starting Node ID or natural language query
   * @param goal - The question to answer
   * @param timeContext - "Time Travel" parameters (asOf, window)
   */
  async findPath(
    start: string | { query: string },
    goal: string,
    timeContext?: TimeContext
  ): Promise<LabyrinthArtifact | null> {
    return this.tracer.startActiveSpan('labyrinth.findPath', async (span: Span) => {
        try {
            const workflow = mastra.getWorkflow('labyrinthWorkflow');
            if (!workflow) throw new Error("Labyrinth Workflow not registered in Mastra.");

            // 1. Prepare Input Data & Configuration
            const inputData = {
                goal,
                start,
                // Domain is left undefined here; the 'route-domain' step will decide it
                // unless we wanted to force it via config.
                maxHops: this.config.maxHops,
                maxCursors: this.config.maxCursors,
                confidenceThreshold: this.config.confidenceThreshold,
                timeContext: timeContext ? {
                    asOf: timeContext.asOf instanceof Date ? timeContext.asOf.getTime() : timeContext.asOf,
                    windowStart: timeContext.windowStart?.toISOString(),
                    windowEnd: timeContext.windowEnd?.toISOString()
                } : undefined
            };

            // 2. Execute Workflow
            const run = await workflow.createRunAsync();
            
            // The workflow steps are responsible for extracting timeContext from input
            // and passing it to agents via runtimeContext injection in the 'speculative-traversal' step.
            const result = await run.start({ inputData });
            
            // 3. Extract Result
            // @ts-expect-error - Result payload typing
            const artifact = result.results?.artifact as LabyrinthArtifact | null;
            if (!artifact && result.status === 'failed') {
                 throw new Error(`Workflow failed: ${result.error?.message || 'Unknown error'}`);
            }

            if (artifact) {
              // Sync traceId with the actual Run ID for retrievability
              // @ts-expect-error - runId access
              const runId = run.runId || run.id;
              artifact.traceId = runId;

              span.setAttribute('labyrinth.confidence', artifact.confidence);
              span.setAttribute('labyrinth.traceId', artifact.traceId);

              // Cache the full artifact (with heavy execution trace)
              this.traceCache.set(runId, JSON.parse(JSON.stringify(artifact)));

              // Return "Executive Briefing" version (strip execution logs)
              if (artifact.metadata) {
                 artifact.metadata.execution = []; 
              }
            }

            return artifact;

        } catch (e) {
            this.logger.error("Labyrinth traversal failed", { error: e });
            span.recordException(e as Error);
            throw e;
        } finally {
            span.end();
        }
    });
  }

  /**
   * Retrieve the full reasoning trace for a specific run.
   * Useful for auditing or "Show your work" features.
   */
  async getTrace(traceId: string): Promise<LabyrinthArtifact | undefined> {
    // 1. Try Memory Cache
    if (this.traceCache.has(traceId)) {
        return this.traceCache.get(traceId);
    }

    // 2. Future: Try Mastra Storage (DB)
    // const run = await mastra.getRun(traceId);
    // return run?.result?.artifact;

    return undefined;
  }

  /**
   * Direct access to Chronos for temporal analytics.
   * Useful for "Life Coach" dashboards that need raw stats without full agent traversal.
   */
  async analyzeCorrelation(
    anchorNodeId: string,
    targetLabel: string,
    windowMinutes: number
  ): Promise<CorrelationResult> {
    return this.chronos.analyzeCorrelation(anchorNodeId, targetLabel, windowMinutes);
  }

  /**
   * Execute a Natural Language Mutation.
   * Uses the Scribe Agent to parse intent and apply graph operations.
   */
  async mutate(query: string, timeContext?: TimeContext): Promise<{ success: boolean; summary: string }> {
    return this.tracer.startActiveSpan('labyrinth.mutate', async (span: Span) => {
      try {
        const workflow = mastra.getWorkflow('mutationWorkflow');
        if (!workflow) throw new Error("Mutation Workflow not registered.");

        const inputData = {
          query,
          asOf: timeContext?.asOf instanceof Date ? timeContext.asOf.getTime() : timeContext?.asOf,
          userId: 'Me' // Default context
        };

        const run = await workflow.createRunAsync();
        const result = await run.start({ inputData });
        if (result.status === 'failed') {
          throw new Error(`Mutation failed: ${result.error.message}`);
        }
        if (result.status !== 'success') {
          throw new Error(`Mutation failed with status: ${result.status}`);
        }
        return result.result as { success: boolean; summary: string };
          } catch (e) {
            this.logger.error("Mutation failed", { error: e });
            span.recordException(e as Error);
            return { success: false, summary: `Mutation failed: ${(e as Error).message}` };
          } finally {
            span.end();
          }
    });
  }
}