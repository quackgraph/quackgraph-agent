import { describe, it, expect, beforeAll } from "bun:test";
import { runWithTestGraph } from "../utils/test-graph";
import { SyntheticLLM } from "../utils/synthetic-llm";
import { scoutAgent } from "../../src/mastra/agents/scout-agent";
import { judgeAgent } from "../../src/mastra/agents/judge-agent";
import { routerAgent } from "../../src/mastra/agents/router-agent";
import { mastra } from "../../src/mastra/index";

interface LabyrinthResult {
  artifact: {
    answer: string;
    sources: string[];
  } | null;
}

describe("E2E: The Time Traveler (Labyrinth Workflow)", () => {
  let llm: SyntheticLLM;

  beforeAll(() => {
    llm = new SyntheticLLM();
    // Safe defaults
    llm.mockAgent(scoutAgent, { action: "ABORT", confidence: 0, reasoning: "Default Abort" });
    llm.mockAgent(judgeAgent, { isAnswer: false, answer: "No", confidence: 0 });
    llm.mockAgent(routerAgent, { domain: "global", confidence: 1, reasoning: "Default Global" });
  });

  it("returns different answers for 2023 vs 2024 contexts", async () => {
    await runWithTestGraph(async (graph) => {
      // Topology: Employee managed by different people at different times
      // @ts-expect-error
      await graph.addNode("dave", ["Employee"], { name: "Dave" });
      // @ts-expect-error
      await graph.addNode("alice", ["Manager"], { name: "Alice" }); // 2023
      // @ts-expect-error
      await graph.addNode("bob", ["Manager"], { name: "Bob" });     // 2024

      const t2023_start = new Date("2023-01-01").toISOString();
      const t2023_end   = new Date("2023-12-31").toISOString();
      const t2024_start = new Date("2024-01-01").toISOString();

      // Dave --(MANAGED_BY)--> Alice (2023 only)
      // @ts-expect-error
      await graph.addEdges([{ 
        source: "dave", target: "alice", type: "MANAGED_BY", properties: {}, 
        validFrom: new Date(t2023_start), validTo: new Date(t2023_end) 
      }]);

      // Dave --(MANAGED_BY)--> Bob (2024 onwards)
      // @ts-expect-error
      await graph.addEdges([{ 
        source: "dave", target: "bob", type: "MANAGED_BY", properties: {}, 
        validFrom: new Date(t2024_start)
      }]);

      // --- Train the Synthetic Brain ---
      
      // Router: Always Global
      llm.addResponse("Who managed Dave", { domain: "global", confidence: 1.0, reasoning: "HR Query" });

      // Scout: Sees MANAGED_BY edges. 
      // NOTE: The Scout prompt contains the sector summary. 
      // The sector summary is generated by GraphTools, which respects `asOf`.
      // So if asOf=2023, Scout only sees Alice. If asOf=2024, Scout only sees Bob.
      
      // Generic move response (Scout decides based on what it sees)
      // We'll trust the "Ghost Earth" logic: if it sees an edge, it takes it.
      llm.setDefault({
        action: "MOVE",
        edgeType: "MANAGED_BY",
        confidence: 0.9,
        reasoning: "Following management chain",
        // Safety fields for other agents (Router/Judge) if they fall back
        domain: "global",
        isAnswer: false,
        answer: "Fallback"
      });

      // Special case: If at Alice or Bob, Check for answer
      llm.addResponse(`Node: "alice"`, { action: "CHECK", confidence: 1.0, reasoning: "Checking Alice" });
      llm.addResponse(`Node: "bob"`, { action: "CHECK", confidence: 1.0, reasoning: "Checking Bob" });

      // Judge: Confirms answer
      llm.addResponse(`Node: "alice"`, { isAnswer: true, answer: "Manager was Alice", confidence: 1.0 }); // Wrong prompt key, relying on content retrieval mock implicitly or explicit pattern
      // Let's make Judge robust:
      llm.addResponse(`"name":"Alice"`, { isAnswer: true, answer: "Manager was Alice", confidence: 1.0 });
      llm.addResponse(`"name":"Bob"`, { isAnswer: true, answer: "Manager was Bob", confidence: 1.0 });


      // --- Execution 1: Query as of mid-2023 ---
      const run2023 = await mastra.getWorkflow("labyrinthWorkflow").createRunAsync();
      const res2023 = await run2023.start({
        inputData: {
          goal: "Who managed Dave?",
          start: "dave",
          timeContext: { asOf: new Date("2023-06-15").getTime() }
        }
      });

      // @ts-expect-error
      if (res2023.status === "failed") throw new Error(`Workflow failed: ${res2023.error?.message}`);

      // @ts-expect-error
      const payload2023 = res2023.results || res2023;
      const art2023 = (payload2023 as LabyrinthResult)?.artifact;
      expect(art2023).toBeDefined();
      expect(art2023?.answer).toContain("Alice");
      expect(art2023?.sources).toContain("alice");


      // --- Execution 2: Query as of 2024 ---
      const run2024 = await mastra.getWorkflow("labyrinthWorkflow").createRunAsync();
      const res2024 = await run2024.start({
        inputData: {
          goal: "Who managed Dave?",
          start: "dave",
          timeContext: { asOf: new Date("2024-06-15").getTime() }
        }
      });

      // @ts-expect-error
      if (res2024.status === "failed") throw new Error(`Workflow failed: ${res2024.error?.message}`);

      // @ts-expect-error
      const payload2024 = res2024.results || res2024;
      const art2024 = (payload2024 as LabyrinthResult)?.artifact;
      expect(art2024).toBeDefined();
      expect(art2024?.answer).toContain("Bob");
      expect(art2024?.sources).toContain("bob");
    });
  });
});